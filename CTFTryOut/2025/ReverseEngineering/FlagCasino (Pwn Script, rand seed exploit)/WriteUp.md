## Description
The team stumbles into a long-abandoned casino. As you enter, the lights and music whir to life, and a staff of robots begin moving around and offering games, while skeletons of prewar patrons are slumped at slot machines. 
A robotic dealer waves you over and promises great wealth if you can win - can you beat the house and gather funds for the mission?
## Difficulty
Very easy
## Steps to Flag
The program starts by asking user input to place bets.  
```
┌──(kali㉿kali)-[~/HTBTryout/Flagcasino/rev_flagcasino]
└─$ ./casino
[ ** WELCOME TO ROBO CASINO **]
     ,     ,
    (\____/)
     (_oo_)
       (O)
     __||__    \)
  []/______\[] /
  / \______/ \/
 /    /__\
(\   /____\
---------------------
[*** PLEASE PLACE YOUR BETS ***]
>

┌──(kali㉿kali)-[~/HTBTryout/Flagcasino/rev_flagcasino]
└─$ ./casino
[ ** WELCOME TO ROBO CASINO **]
     ,     ,
    (\____/)
     (_oo_)
       (O)
     __||__    \)
  []/______\[] /
  / \______/ \/
 /    /__\
(\   /____\
---------------------
[*** PLEASE PLACE YOUR BETS ***]
> 1
[ * INCORRECT * ]
[ *** ACTIVATING SECURITY SYSTEM - PLEASE VACATE *** ]
```
First I check what is the file type.  
```
┌──(kali㉿kali)-[~/HTBTryout/Flagcasino/rev_flagcasino]
└─$ file casino
casino: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=ac3d9d8a2c65ca7a0cb88af07efaec8c991c315d, for GNU/Linux 3.2.0, not stripped
```
Then I decompile the file using ghidra.  
```
undefined8 main(void)

{
  int iVar1;
  char local_d;
  uint counter;
  
  puts("[ ** WELCOME TO ROBO CASINO **]");
  puts(
      "     ,     ,\n    (\\____/)\n     (_oo_)\n       (O)\n     __||__    \\)\n  []/______\\[] /\n   / \\______/ \\/\n /    /__\\\n(\\   /____\\\n---------------------"
      );
  puts("[*** PLEASE PLACE YOUR BETS ***]");
  counter = 0;
  while( true ) {
    if (28 < counter) {
      puts("[ ** HOUSE BALANCE $0 - PLEASE COME BACK LATER ** ]");
      return 0;
    }
    printf("> ");
    iVar1 = __isoc99_scanf(&DAT_5555555560fc,&local_d);
    if (iVar1 != 1) break;
    srand((int)local_d);
    iVar1 = rand();
    if (iVar1 != *(int *)(&check + (long)(int)counter * 4)) {
      puts("[ * INCORRECT * ]");
      puts("[ *** ACTIVATING SECURITY SYSTEM - PLEASE VACATE *** ]");
                    /* WARNING: Subroutine does not return */
      exit(-2);
    }
    puts("[ * CORRECT *]");
    counter = counter + 1;
  }
                    /* WARNING: Subroutine does not return */
  exit(-1);
}
```
It seems like the code first ask for user input and use that as the seed for a random number generator.  
Then it checks the random number with a pre fixed numbers stored in the the memory address of check.  
If the number is correct, it repeats for 28 times.  
First thought, since the checking of user input is based on ```check```, the flag must be stored in check.  
**Note: Using srand(x) followed by rand() will always produce the same result for a given seed.**  
If user input is check with the check that stores the flag, to test my theory.  
```
┌──(kali㉿kali)-[~/HTBTryout/Flagcasino/rev_flagcasino]
└─$ ./casino
[ ** WELCOME TO ROBO CASINO **]
     ,     ,
    (\____/)
     (_oo_)
       (O)
     __||__    \)
  []/______\[] /
  / \______/ \/
 /    /__\
(\   /____\
---------------------
[*** PLEASE PLACE YOUR BETS ***]
> H
[ * CORRECT *]
> T
[ * CORRECT *]
> B
[ * CORRECT *]
> {
[ * CORRECT *]
> 
```
For example:  
```
srand((int)"H");
34 = rand();
if (34 != &check + 0)
  ...
else
  puts("[ * CORRECT *]");
```

Script used:
```
import ctypes
from pwn import *

libc = ctypes.CDLL('/lib/x86_64-linux-gnu/libc.so.6')
mapping = {}
for i in range(255):         #1
    libc.srand(i)
    mapping[libc.rand()] = chr(i)
flag = ""

casino = ELF("./casino", checksec=False)    #2
for b in range(29):
    val = casino.u32(casino.sym["check"] + b * 4)  #3
    flag += mapping[val]
print(flag)
```
**Explaination:**   
**1** :
Using every char as the seed and maps the respectively random number for each char used as the seed.  
![ScreenShot](https://imgur.com/zF7vbt1.png)  
**2** :  
Loading the ELF Binary:  
  - This line loads the binary file ./casino into a Pwntools ELF object.  
  - The ELF object allows you to interact with the binary in a more structured way (for example, by accessing functions,       symbols, or sections).

The Path ("./casino"):
  - This specifies the path to the ELF binary. The ./casino means that the binary casino is in the current directory.

The checksec=False:
  - This tells Pwntools not to check for various security mechanisms (like stack canaries, NX, ASLR, etc.) when loading the     binary.
  - By setting checksec=False, you are disabling the check for security settings that might otherwise make exploitation         more difficult.
  - It's often used in CTF challenges where security checks might interfere with debugging or analysis.
**3**:
It then checks with the pre-fixed number stored in memory address starting from &check.  
Since each int bytes is 4 and stored consecutively, it increment the memory by 4 bytes.
![ScreenShot](https://imgur.com/PX8vAOE.png)    

** This challenge, it maps a number with each char of the flag and not use the ascii values of the flag**

**Flag**:  
```
HTB{r4nd_1s_v3ry_pr3d1ct4bl3}
```
## Writeup Link:  
https://motasemhamdan.medium.com/hackthebox-flag-casino-reverse-engineering-ctf-writeups-2247bc6dafee

